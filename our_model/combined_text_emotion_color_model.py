# -*- coding: utf-8 -*-
"""Combined_text-emotion-color_model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p9-Qc21wsp3yk6rxXEm3vT9Yh6c7CkCQ
"""

# -*- coding: utf-8 -*-
"""
Combined Script for Emotion-Based Diary Background Color Recommendation
"""

import pandas as pd
import re
import numpy as np
import colorsys
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import os

# ==============================================================================
# PART 1: TEXT-TO-EMOTION MODEL (from acdt_model_v1_text_to_emotion.py)
# ==============================================================================

print("--- Initializing Text-to-Emotion Model ---")

# --- 1.1. Data Loading ---
# Note: Please ensure 'emotion_sentimen_dataset.csv' is in the same directory
# or provide the full path to the file.
try:
    text_emotion_df = pd.read_csv('./emotion_sentimen_dataset.csv', encoding='latin1', on_bad_lines='skip')
except FileNotFoundError:
    print("Error: 'emotion_sentimen_dataset.csv' not found.")
    print("Please make sure the dataset for the text-to-emotion model is available.")
    raise

# --- 1.2. Data Cleaning (English text only) ---
try:
    df_renamed = text_emotion_df.rename(columns={'Emotion': 'label', 'text': 'text'})
    df_clean = df_renamed[['text', 'label']]
except KeyError:
    print("Error: 'text' or 'Emotion' column not found in the text emotion dataset.")
    raise

def clean_text(text):
    if not isinstance(text, str):
        return ""
    text = text.lower()
    text = re.sub(r'[^a-zA-Z\s]', '', text)
    text = re.sub(r'\s+', ' ', text).strip()
    return text

df_clean['text'] = df_clean['text'].apply(clean_text)
df_clean.dropna(subset=['text', 'label'], inplace=True)
df_final = df_clean[df_clean['text'] != ""]

# --- 1.3. Label Mapping (excluding 'neutral') ---
# 원본 모델(acdt_model_v1_text_to_emotion.py)의 매핑 로직 적용
label_map = {
    # 1. joy / Happiness
    'happiness': 'Happiness',
    'fun': 'Happiness',
    'enthusiasm': 'Happiness',
    'relief': 'Happiness',
    'love': 'Happiness',

    # 2. sadness / Sadness
    'sadness': 'Sadness',
    'empty': 'Sadness',
    'boredom': 'Sadness',

    # 3. anger / Anger
    'anger': 'Anger',

    # 4. fear / Fear
    'worry': 'Fear',

    # 5. disgust / Disgust
    'hate': 'Disgust',

    # 6. surprise / Surprise
    'surprise': 'Surprise'

    # 'neutral' 항목은 의도적으로 제외됨
}
df_final['label'] = df_final['label'].map(label_map)

# 'neutral' 및 매핑되지 않은 데이터 제거
df_final = df_final.dropna(subset=['label'])

print("--- 6가지 감정 ('neutral' 제외)으로 정제된 데이터 ---")
print(df_final['label'].value_counts())
print("\n" + "="*50 + "\n")

# --- 1.4. Training/Test Data Split ---
# 원본 모델의 훈련/테스트 데이터 분리 로직 적용
X_text = df_final['text']
y_text = df_final['label']

print(f"훈련 데이터 (6개 감정): 전체 샘플 {len(df_final)}개")
print(f"감정별 분포:\n{y_text.value_counts()}\n")

X_train_text, X_test_text, y_train_text, y_test_text = train_test_split(
    X_text, y_text,
    test_size=0.2,           # 20%를 테스트 데이터로 사용
    random_state=42,         # 재현 가능성을 위한 시드
    stratify=y_text          # 6개 감정 간의 불균형을 맞춤
)

print(f"훈련 데이터: {len(X_train_text)}개")
print(f"테스트 데이터: {len(X_test_text)}개\n")

# --- 1.5. TF-IDF Vectorization ---
# 영어 불용어 처리 적용 (a, the, is 등 제거)
tfidf_vectorizer = TfidfVectorizer(
    max_features=5000,
    stop_words='english'  # 영어 불용어 자동 제거
)
X_train_tfidf = tfidf_vectorizer.fit_transform(X_train_text)
X_test_tfidf = tfidf_vectorizer.transform(X_test_text)

print(f"TF-IDF 벡터 shape (훈련): {X_train_tfidf.shape}")
print(f"TF-IDF 벡터 shape (테스트): {X_test_tfidf.shape}\n")

# --- 1.6. Model Training ---
# 원본 모델의 가중치 균형 처리 적용
text_emotion_model = LogisticRegression(
    max_iter=1000,
    random_state=42,
    class_weight='balanced'  # 감정별 불균형 해결 (joy는 8만, fear는 4천 등)
)
print("훈련 중 (Text-to-Emotion 모델)...")
text_emotion_model.fit(X_train_tfidf, y_train_text)

# 모델 성능 평가
y_pred_text = text_emotion_model.predict(X_test_tfidf)
text_accuracy = accuracy_score(y_test_text, y_pred_text)
print(f"✅ Text-to-Emotion 모델 훈련 완료 (정확도: {text_accuracy*100:.2f}%)\n")

# ==============================================================================
# PART 2: EMOTION-TO-COLOR RECOMMENDATION MODEL (from colorchoosing.py)
# ==============================================================================

print("\n--- Initializing Emotion-to-Color Recommendation Model ---")

# --- 2.1. Data Loading ---
# IMPORTANT: Replace 'your_file_name.csv' with the actual name of your color-emotion CSV file.
try:
    color_emotion_file_path = 'your_file_name.csv'
    color_data = pd.read_csv(color_emotion_file_path)
except FileNotFoundError:
    print(f"Error: '{color_emotion_file_path}' not found.")
    print("Please replace 'your_file_name.csv' with the correct file path for the color-emotion data.")
    raise

# --- 2.2. Feature and Label Separation ---
X_color = color_data[['h', 's', 'v']]
y_color = color_data['emotion']

# --- 2.3. Label Encoding ---
color_label_encoder = LabelEncoder()
y_encoded_color = color_label_encoder.fit_transform(y_color)

# --- 2.4. Training/Test Data Split ---
X_train_color, X_test_color, y_train_color, y_test_color = train_test_split(
    X_color, y_encoded_color, test_size=0.2, random_state=42
)

# --- 2.5. Model Training ---
color_recommendation_model = RandomForestClassifier(n_estimators=100, random_state=42)
print("Training the emotion-to-color recommendation model...")
color_recommendation_model.fit(X_train_color, y_train_color)
print("Emotion-to-color model training complete.")

# --- 2.6. Color Tone Adjustment Functions ---
def to_bright_pastel_hsv(hsv_color):
    h, s, v = hsv_color
    pastel_s = max(0.1, min(0.4, s * 0.5))
    pastel_v = max(0.8, min(1.0, v * 0.2 + 0.8))
    return (h, pastel_s, pastel_v)

def to_dark_calm_hsv(hsv_color):
    h, s, v = hsv_color
    dark_s = max(0.2, min(0.7, s * 0.7))
    dark_v = max(0.2, min(0.6, v * 0.6))
    return (h, dark_s, dark_v)

def hsv_to_hex(hsv_color):
    """HSV 색상을 HEX 코드 문자열로 변환"""
    rgb = colorsys.hsv_to_rgb(*hsv_color)
    hex_color = '#{:02x}{:02x}{:02x}'.format(
        int(rgb[0] * 255),
        int(rgb[1] * 255),
        int(rgb[2] * 255)
    )
    return hex_color.upper()

# ==============================================================================
# PART 3: COMBINED WORKFLOW - MAIN FUNCTION
# ==============================================================================

def analyze_emotion_and_color(diary_entry, show_visualization=False):
    """
    일기 텍스트를 분석하여 감정과 배경색을 추천하는 함수
    
    Args:
        diary_entry (str): 분석할 일기 텍스트
        show_visualization (bool): 시각화 여부 (기본값: False)
    
    Returns:
        dict: {'emotion': str, 'color_hex': str, 'color_name': str, 'tone': str}
    """
    
    # --- 3.1. Predict Emotion from Text ---
    cleaned_text = clean_text(diary_entry)
    text_vector = tfidf_vectorizer.transform([cleaned_text])
    predicted_emotion = text_emotion_model.predict(text_vector)[0]
    
    print(f"감정 분석 결과: {predicted_emotion}")
    
    # --- 3.2. Recommend Color Based on Emotion ---
    try:
        selected_encoded_label = color_label_encoder.transform([predicted_emotion])[0]

        # Filter training data for samples the model predicts as the selected emotion
        y_train_pred_color = color_recommendation_model.predict(X_train_color)
        filtered_indices = np.where(y_train_pred_color == selected_encoded_label)[0]

        if len(filtered_indices) > 0:
            # Randomly select one of the filtered samples
            random_index = np.random.choice(filtered_indices)
            selected_hsv_color = tuple(X_train_color.iloc[random_index].values)
        else:
            # Fallback to predefined colors if no samples are found
            print(f"경고: '{predicted_emotion}' 감정에 대한 학습 데이터가 없습니다. 기본 색상을 사용합니다.")
            emotion_colors_hsv = {
                'Anger': (0.0, 0.8, 0.7), 'Disgust': (0.33, 0.7, 0.6),
                'Fear': (0.67, 0.8, 0.5), 'Happiness': (0.17, 0.7, 0.8),
                'Sadness': (0.6, 0.5, 0.4), 'Surprise': (0.5, 0.6, 0.9)
            }
            selected_hsv_color = emotion_colors_hsv.get(predicted_emotion, (0.5, 0.5, 0.8))

    except ValueError:
        print(f"경고: '{predicted_emotion}' 감정이 색상 모델 학습 데이터에 없습니다. 기본 색상을 사용합니다.")
        emotion_colors_hsv = {
            'Anger': (0.0, 0.8, 0.7), 'Disgust': (0.33, 0.7, 0.6),
            'Fear': (0.67, 0.8, 0.5), 'Happiness': (0.17, 0.7, 0.8),
            'Sadness': (0.6, 0.5, 0.4), 'Surprise': (0.5, 0.6, 0.9)
        }
        selected_hsv_color = emotion_colors_hsv.get(predicted_emotion, (0.5, 0.5, 0.8))

    # --- 3.3. Adjust Color Tone Based on Emotion ---
    negative_emotions = ['Anger', 'Disgust', 'Fear', 'Sadness']
    if predicted_emotion in negative_emotions:
        corrected_hsv_color = to_dark_calm_hsv(selected_hsv_color)
        tone_label = '차분하고 어두운 톤'
    else:
        corrected_hsv_color = to_bright_pastel_hsv(selected_hsv_color)
        tone_label = '밝고 파스텔 톤'

    # --- 3.4. Convert to HEX color code ---
    color_hex = hsv_to_hex(corrected_hsv_color)
    
    # --- 3.5. Get color name based on emotion ---
    emotion_color_names = {
        'Anger': '진한 빨강', 'Disgust': '황록색', 'Fear': '밤색',
        'Happiness': '황금색', 'Sadness': '파란색', 'Surprise': '보라색'
    }
    color_name = emotion_color_names.get(predicted_emotion, '중립 회색')

    result = {
        'emotion': predicted_emotion,
        'color_hex': color_hex,
        'color_name': color_name,
        'tone': tone_label
    }
    
    # --- 3.6. Visualization (Optional) ---
    if show_visualization:
        original_rgb = colorsys.hsv_to_rgb(*selected_hsv_color)
        corrected_rgb = colorsys.hsv_to_rgb(*corrected_hsv_color)
        
        print(f"원본 추천 HSV 색상: {selected_hsv_color}")
        print(f"조정된 HSV 색상 ({tone_label}): {corrected_hsv_color}")
        
        # Visualization
        fig, ax = plt.subplots(1, 2, figsize=(12, 6))
        
        # Original Color
        ax[0].add_patch(patches.Rectangle((0, 0), 1, 1, facecolor=original_rgb))
        ax[0].set_title('원본 추천 색상', fontsize=14)
        ax[0].axis('off')
        ax[0].text(0.5, 0.5, f'RGB: ({original_rgb[0]:.2f}, {original_rgb[1]:.2f}, {original_rgb[2]:.2f})',
                   color='white' if sum(original_rgb)/3 < 0.5 else 'black', ha='center', va='center', fontsize=12)
        
        # Corrected Color
        ax[1].add_patch(patches.Rectangle((0, 0), 1, 1, facecolor=corrected_rgb))
        ax[1].set_title(f'조정된 색상: {tone_label}', fontsize=14)
        ax[1].axis('off')
        ax[1].text(0.5, 0.5, f'HEX: {color_hex}\n{color_name}',
                   color='white' if sum(corrected_rgb)/3 < 0.5 else 'black', ha='center', va='center', fontsize=12)
        
        plt.suptitle(f'감정: {predicted_emotion}', fontsize=16)
        plt.tight_layout()
        plt.show()
    
    return result

# ==============================================================================
# EXAMPLE USAGE (Remove or comment out for production use)
# ==============================================================================

# if __name__ == "__main__":
#     # 사용 예시
#     print("=== 감정 분석 및 색상 추천 시스템 ===")
#     print("일기 내용을 입력하면 감정을 분석하고 적절한 배경색을 추천합니다.\n")
#     
#     while True:
#         diary_entry = input("일기 내용을 입력하세요 (종료하려면 'quit' 입력): ")
#         
#         if diary_entry.lower() == 'quit':
#             print("시스템을 종료합니다.")
#             break
#             
#         if not diary_entry.strip():
#             print("내용을 입력해주세요.\n")
#             continue
#         
#         # 감정과 색상 분석
#         result = analyze_emotion_and_color(diary_entry, show_visualization=True)
#         
#         # 결과 출력
#         print("\n=== 분석 결과 ===")
#         print(f"감정: {result['emotion']}")
#         print(f"추천 배경색: {result['color_name']}")
#         print(f"색상 코드: {result['color_hex']}")
#         print(f"톤 스타일: {result['tone']}")
#         print("-" * 50)
#         print()