# -*- coding: utf-8 -*-
"""colorchoosing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HpNTFCp9xstEQhW-5i3oLUA6Qo3aV5it
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# 시각화를 위한 라이브러리 (결과 확인용)
import seaborn as sns
import matplotlib.pyplot as plt

# 1. 데이터 불러오기 (파일 이름을 실제 업로드한 파일명으로 변경하세요)
try:
    file_path = 'your_file_name.csv'  # 예: 'emotion_data.csv'
    data = pd.read_csv(file_path)
    print("--- 1. 원본 데이터 (처음 5줄) ---")
    print(data.head())
except FileNotFoundError:
    print(f"'{file_path}' 파일을 찾을 수 없습니다.")
    print("Google Colab 왼쪽에 있는 파일 아이콘을 클릭하여 CSV 파일을 업로드했는지 확인하세요.")
    # 파일이 없으면 더 이상 진행하지 않음
    raise

# 2. 특징(X)과 라벨(y) 분리
# h, s, v는 예측에 사용할 입력(특징)
X = data[['h', 's', 'v']]
# emotion은 예측할 대상(라벨)
y = data['emotion']

# 3. 라벨 인코딩 (필수!)
# 모델은 'Fear', 'Surprise' 같은 문자열을 이해하지 못합니다.
# 따라서 'Fear' -> 0, 'Surprise' -> 1, 'Disgust' -> 2 처럼 숫자로 변경해야 합니다.
encoder = LabelEncoder()
y_encoded = encoder.fit_transform(y)

print("\n--- 2. 라벨 인코딩 결과 ---")
# zip(y, y_encoded)를 set으로 만들어 중복을 제거하고 어떤 문자가 어떤 숫자로 매핑됐는지 확인
encoding_map = dict(zip(y, y_encoded))
print(f"클래스 매핑: {encoding_map}")

# 4. 학습용 / 테스트용 데이터 분리 (80% 학습, 20% 테스트)
X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, test_size=0.2, random_state=42)

print("\n--- 3. 데이터 분리 결과 ---")
print(f"총 샘플 수: {len(X)}")
print(f"학습 샘플 수: {len(X_train)}")
print(f"테스트 샘플 수: {len(X_test)}")

# 5. 모델 선택 및 학습
print("\n--- 4. 모델 학습 시작 ---")
model = RandomForestClassifier(n_estimators=100, random_state=42)

# 학습용 데이터(X_train, y_train)로 모델을 학습시킵니다.
model.fit(X_train, y_train)

print("모델 학습 완료!")

# 6. 모델 평가 (테스트용 데이터 사용)
print("\n--- 5. 모델 평가 ---")
y_pred = model.predict(X_test)

# 정확도 (Accuracy)
accuracy = accuracy_score(y_test, y_pred)
print(f"정확도: {accuracy * 100:.2f}%")

# 분류 리포트 (Precision, Recall, F1-score)
# target_names를 사용해 숫자 라벨을 다시 문자(감정)로 표시
print("\n[분류 리포트]")
print(classification_report(y_test, y_pred, target_names=encoder.classes_))

# 혼동 행렬 (Confusion Matrix)
print("\n[혼동 행렬]")
cm = confusion_matrix(y_test, y_pred)

# 혼동 행렬 시각화
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=encoder.classes_,
            yticklabels=encoder.classes_)
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Confusion Matrix')
plt.show()

# 7. 새로운 데이터로 예측하기
print("\n--- 6. 새로운 데이터 예측 ---")

# 예: 이미지의 첫 번째 줄 (Fear)와 유사한 값
# h=0.196, s=0.8, v=0.054
new_sample = [[0.196, 0.8, 0.054]]

# 모델 예측 (결과는 숫자로 나옴)
pred_encoded = model.predict(new_sample)

# 숫자 결과를 다시 문자(감정)로 변환
pred_emotion = encoder.inverse_transform(pred_encoded)

print(f"입력 (h,s,v): {new_sample[0]}")
print(f"모델 예측 감정: {pred_emotion[0]}")

# 예: 이미지의 두 번째 줄 (Surprise)와 유사한 값
new_sample_2 = [[0.966, 0.068, 0.834]]
pred_encoded_2 = model.predict(new_sample_2)
pred_emotion_2 = encoder.inverse_transform(pred_encoded_2)

print(f"\n입력 (h,s,v): {new_sample_2[0]}")
print(f"모델 예측 감정: {pred_emotion_2[0]}")

# 7. 사용자에게 감정 선택 요청
print("\n--- 7. 사용자 감정 선택 ---")

emotion_mapping = {
    1: 'Anger',
    2: 'Disgust',
    3: 'Fear',
    4: 'Happiness',
    5: 'Sadness',
    6: 'Surprise'
}

while True:
    user_input = input(f"감정을 선택하세요 ({', '.join([f'{k}: {v}' for k, v in emotion_mapping.items()])}): ")
    try:
        selected_number = int(user_input)
        if selected_number in emotion_mapping:
            selected_emotion = emotion_mapping[selected_number]
            print(f"선택한 감정: {selected_emotion}")
            break
        else:
            print("잘못된 숫자입니다. 1부터 6까지의 숫자를 입력해주세요.")
    except ValueError:
        print("잘못된 입력입니다. 숫자를 입력해주세요.")

# selected_number 변수에 유효한 사용자의 숫자 입력이 저장됩니다.

"""## 모델 기반 색상 추천

### Subtask:
사용자가 선택한 감정에 해당하는 데이터 샘플 중 일부를 모델 예측을 통해 필터링하고, 필터링된 샘플에서 랜덤으로 HSV 색상 값을 추천합니다.

**Reasoning**:
Implement steps 1, 2, 3, and 4 of the instructions to filter training data based on the selected emotion's predicted label, select a random sample if available, or fall back to the predefined color if no samples are found.
"""

import numpy as np # Import numpy for random choice
import colorsys # Import colorsys for color conversions
import matplotlib.patches as patches # Import patches for drawing rectangles in matplotlib


# 1. 사용자 입력 숫자를 인코딩된 숫자 라벨로 변환
# selected_number (1-6) -> selected_emotion ('Anger', 'Disgust', ...)
# selected_emotion ('Anger', 'Disgust', ...) -> encoded_label (0, 1, ...)
selected_emotion_str = emotion_mapping[selected_number]
# Find the encoded label corresponding to the selected emotion string
# We need to reverse the encoding_map or use encoder.transform directly if the emotion string is in the original training data labels
try:
    selected_encoded_label = encoder.transform([selected_emotion_str])[0]
except ValueError:
    print(f"경고: 선택된 감정 '{selected_emotion_str}'은 학습 데이터에 없습니다. 미리 정의된 색상을 사용합니다.")
    # Define default colors if emotion not in training data
    emotion_colors_hsv = {
        'Anger': (0.0, 0.8, 0.7),
        'Disgust': (0.33, 0.7, 0.6),
        'Fear': (0.67, 0.8, 0.5),
        'Happiness': (0.17, 0.7, 0.8),
        'Sadness': (0.6, 0.5, 0.4),
        'Surprise': (0.5, 0.6, 0.9)
    }
    if selected_emotion_str in emotion_colors_hsv:
        selected_hsv_color = emotion_colors_hsv[selected_emotion_str]
        print(f"\n--- 11. 선택된 감정에 해당하는 색상 (미리 정의됨) ---")
        print(f"선택된 감정: {selected_emotion_str}")
        print(f"사용된 HSV 색상: {selected_hsv_color}")
    else:
        print(f"오류: 미리 정의된 색상에도 '{selected_emotion_str}' 감정이 없습니다.")
        raise SystemExit # Exit if no color found

    # Skip the rest of the filtering and random selection steps
    # Assuming we will proceed with the predefined color if filtering fails
    # This will be handled in the next subtask
else:
    # 2. 학습 데이터에서 선택된 감정으로 모델이 예측한 샘플 필터링
    # Predict on the training data itself to find samples the model associates with the selected emotion
    y_train_pred = model.predict(X_train)

    # Filter X_train based on where the model's prediction matches the selected encoded label
    filtered_X_train_indices = np.where(y_train_pred == selected_encoded_label)[0]

    print(f"\n--- 11. 선택된 감정에 해당하는 데이터 필터링 ---")
    print(f"선택된 감정: {selected_emotion_str} (인코딩된 라벨: {selected_encoded_label})")
    print(f"모델이 '{selected_emotion_str}'으로 예측한 학습 샘플 수: {len(filtered_X_train_indices)}")

    # 3. 필터링된 샘플 중에서 랜덤으로 하나 선택하고 HSV 값 추출
    if len(filtered_X_train_indices) > 0:
        random_index_in_filtered = np.random.choice(filtered_X_train_indices)
        random_sample_hsv = X_train.iloc[random_index_in_filtered][['h', 's', 'v']].values.tolist()
        selected_hsv_color = tuple(random_sample_hsv)
        print(f"필터링된 샘플 중 랜덤 선택된 샘플의 인덱스 (원본 X_train 기준): {random_index_in_filtered}")
        print(f"랜덤 선택된 샘ple의 HSV 색상: {selected_hsv_color}")
    else:
        # 4. 필터링된 샘플이 없으면 미리 정의된 색상 사용
        print(f"경고: 모델이 '{selected_emotion_str}'으로 예측한 학습 샘플이 충분하지 않습니다.")
        print("미리 정의된 'emotion_colors_hsv'에서 해당 감정의 색상을 사용합니다.")
        # Define default colors if no samples found
        emotion_colors_hsv = {
            'Anger': (0.0, 0.8, 0.7),
            'Disgust': (0.33, 0.7, 0.6),
            'Fear': (0.67, 0.8, 0.5),
            'Happiness': (0.17, 0.7, 0.8),
            'Sadness': (0.6, 0.5, 0.4),
            'Surprise': (0.5, 0.6, 0.9)
        }
        if selected_emotion_str in emotion_colors_hsv:
            selected_hsv_color = emotion_colors_hsv[selected_emotion_str]
            print(f"사용된 HSV 색상: {selected_hsv_color}")
        else:
            print(f"오류: 미리 정의된 색상에도 '{selected_emotion_str}' 감정이 없습니다.")
            raise SystemExit # Exit if no color found


# selected_hsv_color 변수에 사용자 선택 감정에 해당하는 (필터링된 데이터 기반 또는 미리 정의된) HSV 색상 튜플이 저장됩니다.

"""## 파스텔 톤 변환 함수 수정

### Subtask:
주어진 HSV 색깔을 파스텔 톤으로 변환하는 함수를 수정하여 채도와 명도 조절을 통해 더 밝은 결과가 나오도록 합니다.

**Reasoning**:
Modify the existing `to_pastel_hsv` function to make the pastel color brighter and re-apply it to the selected color, then print the results.
"""

def to_bright_pastel_hsv(hsv_color):
  """HSV 색상을 밝은 파스텔 톤으로 변환합니다."""
  h, s, v = hsv_color
  # 채도를 약간 낮추고, 명도를 높여 밝게 만듭니다.
  pastel_s = s * 0.5
  pastel_v = v * 0.2 + 0.8
  # 값이 유효한 범위(0~1) 내에 있도록 보정합니다.
  pastel_s = max(0.1, min(0.4, pastel_s))
  pastel_v = max(0.8, min(1.0, pastel_v))
  return (h, pastel_s, pastel_v)

def to_dark_calm_hsv(hsv_color):
  """HSV 색상을 어둡고 차분한 톤으로 변환합니다."""
  h, s, v = hsv_color
  # 채도와 명도를 낮춰 어둡고 차분하게 만듭니다.
  dark_s = s * 0.7
  dark_v = v * 0.6
  # 값이 너무 어두워지지 않도록 최소값을 보정합니다.
  dark_s = max(0.2, min(0.7, dark_s))
  dark_v = max(0.2, min(0.6, dark_v))
  return (h, dark_s, dark_v)

# 감정 톤 보정
print(f"\n--- 9. 감정 톤에 따른 색상 보정 결과 ---")
print(f"선택된 감정: {selected_emotion_str}")
print(f"원래 HSV 색상: {selected_hsv_color}")

# 부정적인 감정과 긍정적인 감정을 정의합니다.
negative_emotions = ['Anger', 'Disgust', 'Fear', 'Sadness']

# 감정에 따라 적절한 보정 함수를 호출합니다.
if selected_emotion_str in negative_emotions:
    corrected_hsv_color = to_dark_calm_hsv(selected_hsv_color)
    print(f"보정된 (어둡고 차분한) HSV 색상: {corrected_hsv_color}")
else: # 'Happiness', 'Surprise' 등 긍정적인 감정
    corrected_hsv_color = to_bright_pastel_hsv(selected_hsv_color)
    print(f"보정된 (밝은 파스텔) HSV 색상: {corrected_hsv_color}")

# 1. selected_hsv_color를 RGB 색상으로 변환하고 출력합니다.
r, g, b = colorsys.hsv_to_rgb(*selected_hsv_color)
selected_rgb_color = (r, g, b)
print(f"\n--- 10. 색상 변환 및 시각화 ---")
print(f"추천된 원래 RGB 색상: {selected_rgb_color}")

# 2. corrected_hsv_color를 RGB 색상으로 변환하고 출력합니다.
r_corrected, g_corrected, b_corrected = colorsys.hsv_to_rgb(*corrected_hsv_color)
corrected_rgb_color = (r_corrected, g_corrected, b_corrected)
print(f"보정된 RGB 색상: {corrected_rgb_color}")

# 부정적인 감정 목록을 다시 확인합니다.
negative_emotions = ['Anger', 'Disgust', 'Fear', 'Sadness']
is_negative = selected_emotion_str in negative_emotions

# 3. Matplotlib을 사용하여 두 개의 색상 패치를 시각화합니다.
fig, ax = plt.subplots(1, 2, figsize=(8, 4))

# 원래 색상 패치
rect_original = patches.Rectangle((0, 0), 1, 1, facecolor=selected_rgb_color)
ax[0].add_patch(rect_original)
ax[0].set_title('Original Color')
luminance = 0.299 * r + 0.587 * g + 0.114 * b
text_color_original = 'white' if luminance < 0.5 else 'black'
ax[0].text(0.5, 0.5, f'RGB: ({r:.2f}, {g:.2f}, {b:.2f})', color=text_color_original, ha='center', va='center', fontsize=10)
ax[0].text(0.5, 0.8, selected_emotion_str, color=text_color_original, ha='center', va='center', fontsize=12, fontweight='bold')
ax[0].axis('off')

# 보정된 색상 패치
rect_corrected = patches.Rectangle((0, 0), 1, 1, facecolor=corrected_rgb_color)
ax[1].add_patch(rect_corrected)
# 감정 종류에 따라 제목과 라벨을 변경합니다.
if is_negative:
    corrected_title = 'Dark & Calm Tone'
    corrected_label = 'Calm'
    text_color_corrected = 'white' # 어두운 톤이므로 글씨는 흰색으로 고정
else:
    corrected_title = 'Bright Pastel Tone'
    corrected_label = 'Pastel'
    text_color_corrected = 'black' # 밝은 톤이므로 글씨는 검은색으로 고정

ax[1].set_title(corrected_title)
ax[1].text(0.5, 0.5, f'RGB: ({r_corrected:.2f}, {g_corrected:.2f}, {b_corrected:.2f})', color=text_color_corrected, ha='center', va='center', fontsize=10)
ax[1].text(0.5, 0.8, corrected_label, color=text_color_corrected, ha='center', va='center', fontsize=12, fontweight='bold')
ax[1].axis('off')

# 플롯 제목 설정
plt.suptitle(f'Color Representation for {selected_emotion_str}', fontsize=14)

# 플롯 표시
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()